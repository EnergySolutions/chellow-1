<?xml version="1.0"?>
<csv>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract]]></value>
        <value><![CDATA[POOL]]></value>
        <value><![CDATA[ccl]]></value>
        <value><![CDATA[2007-04-01T00:30Z]]></value>
        <value><![CDATA[]]></value>
        <value><![CDATA['''
def ccl_gbp(hh_value, date):
    return hh_value * contract.rateScript(date).getRate('ccl_rate')
'''

def is_ccl_month(is_green, kwh):
    return not is_green and kwh > 999

def ccl_month_gbp(bill, data_source, whole_data):
    bill.setdefault('ccl-kwh', 0)
    bill.setdefault('ccl-gbp', 0)
    summary = whole_data['summary']
    month_kwh = summary['sum-msp-kwh']
    if month_kwh is None:
        month_kwh = 0
    if is_ccl_month(data_source.is_green, month_kwh):
        bill['ccl-kwh'] += month_kwh
        bill['ccl-gbp'] += month_kwh * data_source.rate(contract.rateScript(summary['finish-date']), 'ccl_rate')]]></value>
        <value><![CDATA[def ccl_rate():
    return 0.004410]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract-rate-script]]></value>
        <value><![CDATA[ccl]]></value>
        <value><![CDATA[2008-04-01T00:30Z]]></value>
        <value><![CDATA[def ccl_rate():
    return 0.004560]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract-rate-script]]></value>
        <value><![CDATA[ccl]]></value>
        <value><![CDATA[2009-04-01T00:30Z]]></value>
        <value><![CDATA[def ccl_rate():
    return 0.0047]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract]]></value>
        <value><![CDATA[POOL]]></value>
        <value><![CDATA[computer]]></value>
        <value><![CDATA[2009-11-27T00:00Z]]></value>
        <value><![CDATA[]]></value>
        <value><![CDATA[from net.sf.chellow.billing import NonCoreContract
from net.sf.chellow.physical import HhStartDate, MpanCore, Site
from java.util import GregorianCalendar, TimeZone, Locale, Calendar, Date
from net.sf.chellow.monad import UserException, Hiber
from net.sf.chellow.monad.types import MonadDate
from java.sql import Timestamp, ResultSet
from java.lang import System
from org.python.util import PythonInterpreter


cons_types = ['construction', 'commissioning', 'operation']
lec_cats = ['import-net', 'export-net', 'import-gen', 'export-gen', 'import-3rd-party', 'export-3rd-party']

interp_cache = {}

rate_interp_cache = {}

def contract_function(contract, func_name):
    contract_id = contract.getId()
    if contract_id not in interp_cache:
        interp = PythonInterpreter()
        interp.set('contract', contract)
        interp.exec(contract.getChargeScript())
        interp_cache[contract_id] = interp
        
    return interp_cache[contract_id].get(func_name)


def rate(script, name):
    script_id = script.getId()
    if script_id not in rate_interp_cache:
        interp = PythonInterpreter()
        interp.exec(script.getScript())
        rate_interp_cache[script_id] = interp
    
    try:
        return rate_interp_cache[script_id].get(name)()
    except TypeError:
        raise UserException("Problem getting the function '" + name + "' from the script " + str(script_id) + " from the contract " + script.getContract().getName())


def create_comterp():
    interp = PythonInterpreter()
    interp.exec(contract.getChargeScript())
    return interp


def forecast_date():
    cal = MonadDate.getCalendar()
    cal.set(Calendar.DAY_OF_MONTH, 1)
    cal.set(Calendar.MILLISECOND, 0)
    cal.set(Calendar.SECOND, 0)
    cal.set(Calendar.MINUTE, 0)
    return HhStartDate(cal.getTime())


def import_data_sources(contract, search_term, month_start, month_finish, forecast_date, comterp, pw):
    search_term = search_term.strip()
    # is it a forecast?
    if month_finish.after(forecast_date):
        import_data_sources_from_contract(contract, search_term, month_start, month_finish, forecast_date, comterp, pw)
    else:
        if len(search_term) == 0:
            query = Hiber.session().createQuery("select distinct generation from SupplyGeneration generation where generation.importMpan is not null and generation.importMpan.supplierContract = :contract and generation.startDate.date <= :finishDate and (generation.finishDate is null or generation.finishDate.date >= :startDate)")
        else:
            mpan_core = MpanCore.getMpanCore(search_term)
            supply = mpan_core.getSupply()
            query = Hiber.session().createQuery("select distinct generation from SupplyGeneration generation where generation.supply = :supply and generation.importMpan is not null and generation.importMpan.supplierContract = :contract and generation.startDate.date <= :finishDate and (generation.finishDate is null or generation.finishDate.date >= :startDate)").setEntity('supply', supply)
        generations = query.setEntity('contract', contract).setTimestamp('startDate', month_start.getDate()).setTimestamp('finishDate', month_finish.getDate()).scroll()
        while generations.next():
            generation = generations.get(0)
            mpan = generation.getImportMpan()
            mpan_core = mpan.getCore()
            mpan_core_str = str(mpan_core)
            data_source = SupplySource(forecast_date, comterp, pw)
            data_source.init_from_mpan(month_start, month_finish, mpan)
            yield data_source


def hh_list(date):
    utc_cal = GregorianCalendar(TimeZone.getTimeZone("GMT"), Locale.UK)
    ct_cal = GregorianCalendar(TimeZone.getTimeZone("Europe/London"), Locale.UK)
    utc_cal.setTime(date.getDate())
    ct_cal.setTime(date.getDate())
    return [{'used-kwh': 0, 'hist-kwh': 0, 'msp-kwh': 0, 'msp-kvarh': 0, 'end-date': date.getDate(), 'ct-day': ct_cal.get(5), 'utc-month': utc_cal.get(2), 'utc-day': utc_cal.get(5), 'utc-decimal-hour': utc_cal.get(11) + float(utc_cal.get(12)) / 60, 'ct-month': ct_cal.get(2), 'ct-decimal-hour': ct_cal.get(11) + ct_cal.get(12) / 60, 'ct-day-of-week': ct_cal.get(7), 'utc-day-of-week': utc_cal.get(7)}]


class DataSource():
    def dso_hh(self, bill, hh_list):
        #timing = System.currentTimeMillis()
        #self.pw.println("dso_hh: start" + str(System.currentTimeMillis() - timing))
        list_start = HhStartDate(hh_list[0]['start-date'])
        #self.pw.println("dso_hh: list start " + str(list_start))
        for dso_contract in dso_contracts(self.dso_code, list_start, list_start, self.pw):
            finish_date = dso_contract.getFinishRateScript().getFinishDate()
            if HhStartDate(hh_list[-1]['start-date']).after(finish_date):
                for i in range(len(hh_list)):
                    if hh_list[i]['end-date'].after(finish_date.getDate()):

                        self.comterp.get('contract_interpreter')(dso_contract).get('hh')(bill, hh_list[:i], data_source)

                        dso_hh(self, bill, hh_list[i:])
                        break
            else:
                #self.pw.println("dso_hh: list end " + HhStartDate(hh_list[-1]['start-date']).toString())
                contract_function(dso_contract, 'hh')(bill, hh_list, self)
        #self.pw.println("dso_hh: finish " + str(System.currentTimeMillis() - timing))


    def set_is_green(self, is_green):
        self.is_green = is_green
        self.summary['is_green'] = is_green


    def contract_function(self, contract, func_name):
        return contract_function(contract, func_name)


    def rate(self, script, name):
        return rate(script, name)


class SiteSource(DataSource):
    def __init__(self, site, start_date, finish_date, forecast_date, comterp, pw):
        self.forecast_date = forecast_date
        self.site_id = site.getId()
        self.start_date = start_date
        self.finish_date = finish_date
        self.is_new = False
        self.id = site.getCode()
        self.is_green = False
        self.comterp = comterp
        self.pw = pw
        

    def init_from_site(self):
        self.is_site = True
        self.is_displaced = False
        self.whole_data = self.create_whole_data(self.start_date, self.finish_date, forecast_date)
        self.summary = self.whole_data['summary']
        self.hh_data = self.whole_data['data']


    def init_from_mpan(self, mpan):
        self.is_site = True
        self.is_displaced = True
        mpan_core = mpan.getCore()
        dso = mpan_core.getDso()
        self.dso_code = dso.getCode()
        llfc = mpan.getLlfc()
        self.llfc_code = llfc.codeAsString()
        self.is_import = llfc.getIsImport()
        self.id = mpan_core.toString()
        self.voltage_level_code = llfc.getVoltageLevel().getCode()
        self.is_substation = llfc.getIsSubstation()
        self.availability = mpan.getAgreedSupplyCapacity()
        self.pc_code = mpan.getSupplyGeneration().getPc().codeAsString()

        self.whole_data = self.create_whole_data(self.start_date, self.finish_date, forecast_date)
        self.summary = self.whole_data['summary']
        self.hh_data = self.whole_data['data']


    '''
    def hh_list_month(self, month_start):
        cal = MonadDate.getCalendar()
        cal.setTime(month_start)
        cal.add(Calendar.MONTH, 1)
        cal.add(Calendar.MINUTE, -30)
        month_finish = HhStartDate(cal.getTime())
        return self.hh_list(month_start, month_finish, pw)
    '''

    def create_whole_data(self, start_date, finish_date, forecast_date):
        cal = MonadDate.getCalendar()
        cal.setTime(finish_date.getDate())
        year_adjustment = 0
        while cal.getTime().after(self.forecast_date.getDate()):
            cal.add(Calendar.YEAR, -1)
            year_adjustment -= 1
        history_finish = HhStartDate(cal.getTime())
        cal.setTime(start_date.getDate())
        cal.add(Calendar.YEAR, year_adjustment)
        history_start = HhStartDate(cal.getTime())
        summary = {'start-date': start_date, 'finish-date': finish_date, 'is-forecast': not start_date.before(self.forecast_date), 'hist-start': history_start, 'hist-finish': history_finish, 'is-green': self.is_green}
        month_data = {}
        suffixes = ['-kwh', '-kw', '-kvarh', '-kvar', '-kva', '-kvah']
        is_forecast = finish_date.after(self.forecast_date)
        if is_forecast:
            diplaced_kwh = 0
            exported_kwh = 0
            has_gen = False
            month_data['displaced-kwh'] = 0
            month_data['exported-kwh'] = 0                
            site = Site.getSite(self.site_id)
            for gen_forecast in gen_forecasts:
                if gen_forecast['site-code'] == self.site_code:
                    month_data['displaced-kwh'] += gen_forecast['displaced-kwh']
                    month_data['exported-kwh'] += gen_forecast['exported-kwh']
            if 'operation-change-kwh' not in month_data:
                cal = MonadDate.getCalendar()
                for cons_type in cons_types:
                    for suffix in suffixes:
                        month_data[cons_type + suffix] = 0
                for e_change in NonCoreContract.getNonCoreContract('EnergyChanges').rateScript(month_data['start']).getRate('energy_changes'):
                    if e_change['id'] == self.site.getCode():
                        for cons_type in cons_types:
                            start_key = cons_type + '-start'
                            if start_key in e_change:
                                e_change_start = e_change[start_key]
                                e_change_finish = e_change[cons_type + '-finish']
                                if not e_change_start.isAfter(month_finish) and not e_change_finish.isBefore(month_start):
                                    month_length = (month_finish.getDate().getTime() - month_start.getDate().getTime()) / 1000 / 60 / 60
                                    e_change_length = float(min(e_change_finish.getDate().getTime(), month_finish.getDate().getTime()) - max(e_change_start.getDate().getTime(), month_start.getDate().getTime())) / 1000 / 60 / 60
                                    change_kwh = e_change[cons_type + '-kw'] * e_change_length
                                    change_kw = float(change_kwh) / month_length
                                    month_data[cons_type + '-kw'] += change_kw
                                    month_data[cons_type + '-kwh'] += change_kwh
                                    change_kva = change_kw / 0.9
                                    change_kvar = (change_kva ** 2 - change_kw ** 2) ** 0.5
                                    month_data[cons_type + '-kvar'] = change_kvar
                                    month_data[cons_type + '-kvarh'] = change_kvar * change_length
                                    month_data[cons_type + '-kva'] = change_kva
                                    month_data[cons_type + '-kvah'] = change_kva * change_length
                                history_start = summary['hist-start']
                                history_finish = summary['hist-finish']
                                if not e_change_start.isAfter(history_finish) and not e_change_finish.isBefore(history_start):
                                    e_change_length = float(min(e_change_finish.getDate().getTime(), history_finish.getDate().getTime()) - max(e_change_start.getDate().getTime(), history_start.getDate().getTime())) / 1000 / 60 / 60
                                    month_data[cons_type + '-kw'] -= e_change[cons_type + '-kw']
                                    month_data[cons_type + '-kwh'] -= e_change[cons_type + '-kw'] * e_change_length
                                    change_kva = e_change_kw / 0.9
                                    e_change_kvar = (change_kva ** 2 - e_change_kw ** 2) ** 0.5
                                    month_data[cons_type + '-kvar'] = e_change_kvar
                                    month_data[cons_type + '-kvarh'] = e_change_kvar * e_change_length
                                    month_data[cons_type + '-kva'] = change_kva
                                    month_data[cons_type + '-kvah'] = change_kva * e_change_length

        for suffix in suffixes:
            month_data['change' + suffix] = sum(month_data.get(cons_type + '-change' + suffix, 0) for cons_type in cons_types)


        hh_data = []
        utc_cal = GregorianCalendar(TimeZone.getTimeZone("GMT"), Locale.UK)
        ct_cal = GregorianCalendar(TimeZone.getTimeZone("Europe/London"), Locale.UK)
        hh_divisor = (finish_date.getNext().getDate().getTime() - start_date.getDate().getTime()) * 1000 * 60 * 30
        change_kwh = float(month_data['change-kwh']) / hh_divisor

        if is_forecast:
            forecast_displaced_kwh = float(month_data['displaced-kwh']) / hh_divisor
            forecast_exported_kwh = float(month_data['exported-kwh']) / hh_divisor

        site = Site.getSite(self.site_id)
        for group in site.groups(summary['hist-start'], summary['hist-finish'], True):
            hh_start_date = summary['hist-start']
            hh_streams = group.hhData()
            import_net = hh_streams['import-from-net']
            export_net = hh_streams['export-to-net']
            import_gen = hh_streams['import-from-gen']
            export_gen = hh_streams['export-to-gen']
            import_3rd_party = hh_streams['import-from-3rd-party']
            export_3rd_party = hh_streams['export-to-3rd-party']

            for i in range(len(import_net)):
                ct_cal.setTime(hh_start_date.getDate())
                ct_cal.add(Calendar.YEAR, -1 * year_adjustment)
                utc_cal.setTime(hh_start_date.getDate())
                utc_cal.add(Calendar.YEAR, -1 * year_adjustment)
                hh_values = {'hist-import-net-kwh': import_net[i], 'hist-import-net-kvarh': 0, 'hist-export-net-kwh': export_net[i], 'hist-export-net-kvarh': 0, 'hist-import-gen-kwh': import_gen[i], 'hist-export-gen-kwh': export_gen[i], 'hist-import-3rd-party-kwh': import_3rd_party[i], 'hist-export-3rd-party-kwh': export_3rd_party[i], 'start-date': hh_start_date.getDate(), 'ct-day': ct_cal.get(5), 'utc-month': utc_cal.get(2), 'utc-day': utc_cal.get(5), 'utc-decimal-hour': utc_cal.get(11) + float(utc_cal.get(12)) / 60, 'ct-month': ct_cal.get(2), 'ct-decimal-hour': ct_cal.get(11) + ct_cal.get(12) / 60, 'ct-day-of-week': ct_cal.get(7), 'utc-day-of-week': utc_cal.get(7)}
                hh_values['hist-kwh'] = hh_values['hist-import-gen-kwh'] - hh_values['hist-export-gen-kwh'] - hh_values['hist-export-net-kwh']
                if is_forecast:
                    hh_values['msp-kwh'] = forecast_displaced_kwh
                    hh_values['export-net-kwh'] = forecast_exported_kwh
                    hh_values['import-gen-kwh'] = forecast_displaced_kwh + forecast_exported_kwh
                    hh_values['export-gen-kwh'] = 0
                else:
                    hh_values['msp-kwh'] = hh_values['hist-kwh']
                    for lec_cat in lec_cats:
                        hh_values[lec_cat + '-kwh'] = hh_values['hist-' + lec_cat + '-kwh']

                hh_values['hist-used-kwh'] = hh_values['hist-kwh'] + hh_values['hist-import-net-kwh']
                hh_values['hist-imp-msp-kvarh'] = 0
                hh_values['imp-msp-kvarh'] = 0
                hh_values['exp-msp-kvarh'] = 0

                hh_values['used-kwh'] = hh_values['hist-used-kwh'] + change_kwh
                hh_values['import-net-kwh'] = hh_values['used-kwh'] - hh_values['msp-kwh']
                hh_values['change-kwh'] = change_kwh
                hh_values['msp-kw'] = hh_values['msp-kwh'] * 2
                hh_values['imp-msp-kvar'] = hh_values['imp-msp-kvarh'] * 2
                hh_values['exp-msp-kvar'] = hh_values['exp-msp-kvarh'] * 2
                hh_data.append(hh_values)
                hh_start_date = hh_start_date.getNext()

        if len(hh_data) == 0:
            utc_cal = GregorianCalendar(TimeZone.getTimeZone("GMT"), Locale.UK)
            ct_cal = GregorianCalendar(TimeZone.getTimeZone("Europe/London"), Locale.UK)
            utc_cal.setTime(self.finish_date.getDate())
            ct_cal.setTime(self.finish_date.getDate())
            hh_data.append({'status': 'E', 'hist-import-net-kwh': 0, 'hist-import-net-kvarh': 0, 'hist-export-net-kwh': 0, 'hist-export-net-kvarh': 0, 'hist-import-gen-kwh': 0, 'hist-export-gen-kwh': 0, 'hist-import-3rd-party-kwh': 0, 'hist-export-3rd-party-kwh': 0, 'hist-kwh': 0, 'msp-kwh': 0, 'msp-kw': 0, 'export-net-kwh': 0, 'import-gen-kwh': 0, 'export-gen-kwh': 0, 'hist-used-kwh': 0, 'hist-kvarh': 0, 'imp-msp-kvarh': 0, 'imp-msp-kvar': 0, 'exp-msp-kvarh': 0, 'exp-msp-kvar': 0, 'used-kwh': 0, 'import-net-kwh': 0, 'change-kwh': 0, 'import-3rd-party-kwh': 0, 'export-3rd-party-kwh': 0, 'start-date': self.finish_date.getDate(), 'ct-day': ct_cal.get(5), 'utc-month': utc_cal.get(2), 'utc-day': utc_cal.get(5), 'utc-decimal-hour': utc_cal.get(11) + float(utc_cal.get(12)) / 60, 'ct-month': ct_cal.get(2), 'ct-decimal-hour': ct_cal.get(11) + ct_cal.get(12) / 60, 'ct-day-of-week': ct_cal.get(7), 'utc-day-of-week': utc_cal.get(7)})

        if self.is_displaced and self.pc_code == '00' and self.is_import:
            summary['dso-bill'] = {}
            self.dso_hh(summary['dso-bill'], hh_data)


        for name in ['used-kwh', 'hist-kwh', 'import-net-kwh', 'export-net-kwh', 'msp-kwh', 'imp-msp-kvarh', 'import-gen-kwh', 'export-gen-kwh', 'import-3rd-party-kwh', 'export-3rd-party-kwh']:
            datum_list = list(datum[name] for datum in hh_data)
            summary['sum-' + name] = sum(datum_list)
            summary['max-' + name] = max(datum_list)

        return {'summary': summary, 'data': hh_data}


class SupplySource(DataSource):
    def __init__(self, forecast_date, comterp, pw):
        self.forecast_date = forecast_date
        self.whole_data = None
        self.comterp = comterp
        self.pw = pw
        self.is_displaced = False

    def init_from_mpan(self, start_date, finish_date, mpan):
        self.site_id = None
        mpan_core = mpan.getCore()
        self.id = mpan_core.toString()
        self.start_date = start_date
        self.finish_date = finish_date
        self.llfc = mpan.getLlfc()
        self.llfc_code = self.llfc.codeAsString()
        self.voltage_level = self.llfc.getVoltageLevel()
        self.voltage_level_code = self.voltage_level.getCode()
        self.is_substation = self.llfc.getIsSubstation()
        self.dso_code = mpan_core.getDso().getCode()
        self.availability = mpan.getAgreedSupplyCapacity()
        self.is_new = False
        self.supplier_account = mpan.getSupplierAccount()
        if mpan.getSsc() is None:
            self.ssc_code = None
        else:
            self.ssc_code = mpan.getSsc().codeAsString()
        self.pc_code = mpan.getSupplyGeneration().getPc().codeAsString()

        if self.forecast_date.after(start_date):
            generation = mpan.getSupplyGeneration()
            if generation.getStartDate().after(start_date):
                self.start_date = generation.getStartDate()
            else:
                self.start_date = start_date
            if finish_date.after(generation.getFinishDate()):
                self.finish_date = generation.getFinishDate()
            else:
                self.finish_date = finish_date
            self.is_forecast = False
        else:
            self.is_forecast = True
        self.is_import = self.llfc.getIsImport()

        self.whole_data = self.create_whole_data(self.start_date, self.finish_date, self.forecast_date)
        self.summary = self.whole_data['summary']
        self.hh_data = self.whole_data['data']


    def init_from_supply_e_change(self, month_start, month_finish, e_change):
        self.site_id = None
        self.id = e_change['id']
        self.is_new = self.id.startswith('new ')
        self.start_date = month_start
        self.finish_date = month_finish
        self.llfc_code = e_change['llfc']
        self.dso_code = e_change['dso']
        self.is_forecast = True
        self.availability = e_change['availability']
        self.whole_data = self.create_whole_data(self.start_date, self.finish_date)
        self.summary = self.whole_data['summary']
        self.hh_data = self.whole_data['data']


    def hh_list_month(self, month_start):
        cal = MonadDate.getCalendar()
        cal.setTime(month_start)
        cal.add(Calendar.MONTH, 1)
        cal.add(Calendar.MINUTE, -30)
        month_finish = HhStartDate(cal.getTime())
        return self.hh_list(month_start, month_finish, pw)


    def create_whole_data(self, start_date, finish_date, forecast_date):
        timing = System.currentTimeMillis()
        #self.pw.println("starting create whole data start date " + str(start_date) + " finish date " + str(finish_date)  + str(System.currentTimeMillis() - timing))

        cal = MonadDate.getCalendar()
        cal.setTime(finish_date.getDate())
        year_adjustment = 0
        while cal.getTime().after(forecast_date.getDate()):
            cal.add(Calendar.YEAR, -1)
            year_adjustment -= 1
        history_finish = HhStartDate(cal.getTime())
        cal.setTime(start_date.getDate())
        cal.add(Calendar.YEAR, year_adjustment)
        history_start = HhStartDate(cal.getTime())

        summary = {'start-date': start_date, 'finish-date': finish_date, 'is-forecast': not start_date.before(forecast_date), 'hist-start': history_start, 'hist-finish': history_finish}
        month_data = {}
        suffixes = ['-kwh', '-kw', '-kvarh', '-kvar', '-kva', '-kvah']
        is_forecast = finish_date.after(forecast_date)
        if False and is_forecast:
            diplaced_kwh = 0
            exported_kwh = 0
            has_gen = False
            for gen_forecast in gen_forecasts:
                if gen_forecast['displaced-id'] == self.id:
                    displaced_kwh += gen_forecast['displaced-kwh']
                    site = Site.getSite(gen_forecast['site-id'])
                    has_gen = True
                elif gen_forecast['exported-id'] == self.id:
                    exported_kwh += gen_forecast['exported-kwh']
                    site = Site.getSite(gen_forecast['site-id'])
                    has_gen = True
            if has_gen:
                hist_data_source = data_source(forecast_date)
                hist_data_source.init_from_site(site, hist_start_date, hist_finish_date)
                hist_m_data = hist_data_source.month_data(hist_start_date, hist_finish_date)
                hist_data_source.sum_md(m_data)
                future_data_source = data_source(forecast_date)
                future_data_source.init_from_site(site)
                future_m_data = future_data_source.month_data(start_date, finish_date)
                future_data_source.sum_md(m_data)
                if displaced_kwh > 0:
                    month_data['operation-change-kwh'] = future_m_data['imported-kwh'] - hist_m_data['imported-kwh']
                elif exported_kwh > 0:
                    month_data['operation-change-kwh'] = future_m_data['exported-kwh'] - hist_m_data['exported-kwh']

            if 'operation-change-kwh' not in month_data:
                cal = MonadDate.getCalendar()
                for cons_type in cons_types:
                    for suffix in suffixes:
                        month_data[cons_type + suffix] = 0
                for e_change in NonCoreContract.getNonCoreContract('EnergyChanges').rateScript(month_data['start']).getRate('energy_changes'):
                    if (self.site == None and e_change['id'] == self.generation['id']) or (self.site != None and e_change['id'] == self.site.getCode()):
                        for cons_type in cons_types:
                            start_key = cons_type + '-start'
                            if start_key in e_change:
                                e_change_start = e_change[start_key]
                                e_change_finish = e_change[cons_type + '-finish']
                                if not e_change_start.isAfter(month_finish) and not e_change_finish.isBefore(month_start):
                                    month_length = (month_finish.getDate().getTime() - month_start.getDate().getTime()) / 1000 / 60 / 60
                                    e_change_length = float(min(e_change_finish.getDate().getTime(), month_finish.getDate().getTime()) - max(e_change_start.getDate().getTime(), month_start.getDate().getTime())) / 1000 / 60 / 60
                                    change_kwh = e_change[cons_type + '-kw'] * e_change_length
                                    change_kw = float(change_kwh) / month_length
                                    month_data[cons_type + '-kw'] += change_kw
                                    month_data[cons_type + '-kwh'] += change_kwh
                                    change_kva = change_kw / 0.9
                                    change_kvar = (change_kva ** 2 - change_kw ** 2) ** 0.5
                                    month_data[cons_type + '-kvar'] = change_kvar
                                    month_data[cons_type + '-kvarh'] = change_kvar * change_length
                                    month_data[cons_type + '-kva'] = change_kva
                                    month_data[cons_type + '-kvah'] = change_kva * change_length
                                history_start = summary['hist-start']
                                history_finish = summary['hist-finish']
                                if not e_change_start.isAfter(history_finish) and not e_change_finish.isBefore(history_start):
                                    e_change_length = float(min(e_change_finish.getDate().getTime(), history_finish.getDate().getTime()) - max(e_change_start.getDate().getTime(), history_start.getDate().getTime())) / 1000 / 60 / 60
                                    month_data[cons_type + '-kw'] -= e_change[cons_type + '-kw']
                                    month_data[cons_type + '-kwh'] -= e_change[cons_type + '-kw'] * e_change_length
                                    change_kva = e_change_kw / 0.9
                                    e_change_kvar = (change_kva ** 2 - e_change_kw ** 2) ** 0.5
                                    month_data[cons_type + '-kvar'] = e_change_kvar
                                    month_data[cons_type + '-kvarh'] = e_change_kvar * e_change_length
                                    month_data[cons_type + '-kva'] = change_kva
                                    month_data[cons_type + '-kvah'] = change_kva * e_change_length

        for suffix in suffixes:
            month_data['change' + suffix] = sum(month_data.get(cons_type + '-change' + suffix, 0) for cons_type in cons_types)

        #pw.println("done setup " + str(System.currentTimeMillis() - timing))

        data_hh = []
        utc_cal = GregorianCalendar(TimeZone.getTimeZone("GMT"), Locale.UK)
        ct_cal = GregorianCalendar(TimeZone.getTimeZone("Europe/London"), Locale.UK)
        hh_divisor = (finish_date.getNext().getDate().getTime() - start_date.getDate().getTime()) * 1000 * 60 * 30
        change_kwh = float(month_data['change-kwh']) / hh_divisor

        if self.is_new:
            hh_date = self.start_date
            while not hh_date.after(self.finish_date):
                utc_cal.setTime(hh_date)
                ct_cal.setTime(hh_date)
                hh_data.append({'msp-kwh': change_kwh, 'change-kwh': change_kwh, 'hist-kwh': 0, 'start-date': hh_date.getDate(), 'ct-day': ct_cal.get(5), 'utc-month': utc_cal.get(2), 'utc-day': utc_cal.get(5), 'utc-decimal-hour': utc_cal.get(11) + float(utc_cal.get(12)) / 60, 'ct-month': ct_cal.get(2), 'ct-decimal-hour': ct_cal.get(11) + float(ct_cal.get(12)) / 60, 'ct-day-of-week': ct_cal.get(7), 'utc-day-of-week': utc_cal.get(7)})
                hh_date = hh_date.next()
        else:
            #self.pw.println("whole data: about to prepare query " +  str(System.currentTimeMillis() - timing))
            mpan_core = MpanCore.getMpanCore(self.id)
            supply = mpan_core.getSupply()
            con = Hiber.session().connection()
            if self.is_import:
                hql = "select sum(case when channel.is_kwh then hh_datum.value else 0 end) as kwh, max(case when channel.is_kwh then hh_datum.status else '' end) as status, sum(case when not channel.is_kwh and channel.is_import then hh_datum.value else 0 end) as imp_kvarh, sum(case when not channel.is_kwh and not channel.is_import then hh_datum.value else 0  end) as exp_kvarh, hh_datum.start_date from hh_datum, channel, supply_generation where hh_datum.channel_id = channel.id and channel.supply_generation_id = supply_generation.id and supply_generation.supply_id = ? and (channel.is_import = TRUE or channel.is_kwh = FALSE) and hh_datum.start_date >= ? and hh_datum.start_date <= ? group by hh_datum.start_date order by hh_datum.start_date"
            else:
                hql = "select sum(case when channel.is_kwh then hh_datum.value else 0 end) as kwh, max(case when not channel.is_import and channel.is_kwh then hh_datum.status else '' end) as status, sum(case when not channel.is_kwh and channel.is_import then hh_datum.value else 0 end) as imp_kvarh, sum(case when not channel.is_kwh and not channel.is_import then hh_datum.value else 0  end) as exp_kvarh, hh_datum.start_date from hh_datum, channel, supply_generation where hh_datum.channel_id = channel.id and channel.supply_generation_id = supply_generation.id and supply_generation.supply_id = ? and (channel.is_import = FALSE or channel.is_kwh = FALSE) and hh_datum.start_date >= ? and hh_datum.start_date <= ? group by hh_datum.start_date order by hh_datum.start_date"
            stmt = con.prepareStatement(hql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.CLOSE_CURSORS_AT_COMMIT)
            stmt.setLong(1, supply.getId())
            stmt.setTimestamp(2, Timestamp(history_start.getDate().getTime()))
            stmt.setTimestamp(3, Timestamp(history_finish.getDate().getTime()))
            #stmt.setFetchSize(100)
            rs = stmt.executeQuery()
            #self.pw.println("whole data: starting loop " + str(System.currentTimeMillis() - timing))
            year_advance = -1 * year_adjustment
            while rs.next():
                start_date = rs.getTimestamp('start_date')
                msp_kwh = rs.getBigDecimal('kwh').doubleValue()
                imp_kvarh = rs.getBigDecimal('imp_kvarh').doubleValue()
                exp_kvarh = rs.getBigDecimal('exp_kvarh').doubleValue()
                status = rs.getString('status')

                utc_cal.setTime(start_date)
                ct_cal.setTime(start_date)
                utc_cal.add(Calendar.YEAR, year_advance)
                ct_cal.add(Calendar.YEAR, year_advance)

                data_hh.append({'status': status, 'imp-msp-kvarh': imp_kvarh, 'imp-msp-kvar': imp_kvarh * 2, 'exp-msp-kvarh': exp_kvarh, 'exp-msp-kvar': exp_kvarh * 2, 'msp-kw': msp_kwh * 2, 'msp-kwh': msp_kwh, 'change-kwh': change_kwh, 'hist-kwh': msp_kwh, 'hist-start-date': start_date, 'start-date': utc_cal.getTime(), 'ct-day': ct_cal.get(5), 'utc-month': utc_cal.get(2), 'utc-day': utc_cal.get(5), 'utc-decimal-hour': utc_cal.get(11) + float(utc_cal.get(12)) / 60, 'ct-month': ct_cal.get(2), 'ct-decimal-hour': ct_cal.get(11) + float(ct_cal.get(12)) / 60, 'ct-day-of-week': ct_cal.get(7), 'utc-day-of-week': utc_cal.get(7)})

            rs.close()
            stmt.close()

        #self.pw.println("whole data: done looping " + str(System.currentTimeMillis() - timing))
        if len(data_hh) == 0:
            utc_cal = GregorianCalendar(TimeZone.getTimeZone("GMT"), Locale.UK)
            ct_cal = GregorianCalendar(TimeZone.getTimeZone("Europe/London"), Locale.UK)
            utc_cal.setTime(self.finish_date.getDate())
            ct_cal.setTime(self.finish_date.getDate())
            data_hh.append({'status': 'E', 'used-kwh': 0, 'hist-kwh': 0, 'msp-kwh': 0, 'msp-kw': 0, 'imp-msp-kvarh': 0, 'imp-msp-kvar': 0, 'exp-msp-kvarh': 0, 'hist-start-date': history_finish.getDate(), 'start-date': finish_date.getDate(), 'ct-day': ct_cal.get(5), 'utc-month': utc_cal.get(2), 'utc-day': utc_cal.get(5), 'utc-decimal-hour': utc_cal.get(11) + float(utc_cal.get(12)) / 60, 'ct-month': ct_cal.get(2), 'ct-decimal-hour': ct_cal.get(11) + ct_cal.get(12) / 60, 'ct-day-of-week': ct_cal.get(7), 'utc-day-of-week': utc_cal.get(7)})

        for name in ['msp-kwh', 'hist-kwh', 'imp-msp-kvarh', 'exp-msp-kvarh']:
            datum_list = [datum[name] for datum in data_hh]
            summary['sum-' + name] = sum(datum_list)
            summary['max-' + name] = max(datum_list)

        #self.pw.println("whole data: starting dso hh " + str(System.currentTimeMillis() - timing))
        if self.pc_code == '00':
            summary['dso-bill'] = {}
            self.dso_hh(summary['dso-bill'], data_hh)
        #self.pw.println("finished create whole data " + str(System.currentTimeMillis() - timing))

        return {'summary': summary, 'data': data_hh}



def dso_contracts(dso_code, start_date, finish_date, pw):
    return Hiber.session().createQuery("select distinct contract from DsoContract contract join contract.rateScripts script where contract.party.code = :dsoCode and contract.name like 'main%' and script.startDate.date <= :finishDate and (script.finishDate.date is null or script.finishDate.date >= :startDate)").setString('dsoCode', dso_code).setTimestamp('startDate', start_date.getDate()).setTimestamp('finishDate', finish_date.getDate()).list()


def site_source(site, start_date, finish_date, forecast_date, comterp, pw):
    return SiteSource(site, start_date, finish_date, forecast_date, comterp, pw)

def supply_source(forecast_date, comterp, pw):
    #timing = System.currentTimeMillis()
    #pw.println("supply_source: start " + str(System.currentTimeMillis() - timing))

    source = SupplySource(forecast_date, comterp, pw)
    #pw.println("supply_source: finish " + str(System.currentTimeMillis() - timing))
    return source]]></value>
        <value><![CDATA[]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract]]></value>
        <value><![CDATA[POOL]]></value>
        <value><![CDATA[hdc]]></value>
        <value><![CDATA[2000-11-26T00:30Z]]></value>
        <value><![CDATA[]]></value>
        <value><![CDATA[from net.sf.chellow.physical import HhStartDate


def hh(bill, hh_data):
    bill.setdefault('hdc-gsp-kwh', 0)
    bill.setdefault('hdc-msp-kwh', 0)
    bill.setdefault('hdc-gbp', 0)

    head_list = hh_data
    tail_list = None

    for rate_script in contract.rateScripts(HhStartDate(hh_data[0]['end-date']), HhStartDate(hh_data[-1]['end-date'])):
        rate_script_finish = rate_script.getFinishDate()
        hdc_rate = rate_script.getRate('hdc_gbp_per_gsp_kwh')
        if HhStartDate(hh_data[-1]['end-date']).after(rate_script_finish):
            for i in range(len(head_list)):
                if head_list[i]['end-date'].after(rate_script_finish.getDate()):
                    tail_list = head_list[i:]
                    head_list = head_list[:i]
                    break
        for datum in head_list:
            bill['hdc-msp-kwh'] += datum['msp-kwh']
            bill['hdc-gsp-kwh'] += datum['gsp-kwh']
            bill['hdc-gbp'] += datum['gsp-kwh'] * hdc_rate]]></value>
        <value><![CDATA[def hdc_gbp_per_gsp_kwh():
    return 0.00016456]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract]]></value>
        <value><![CDATA[POOL]]></value>
        <value><![CDATA[TRIAD]]></value>
        <value><![CDATA[2005-04-01T00:00Z]]></value>
        <value><![CDATA[]]></value>
        <value><![CDATA[from net.sf.chellow.billing import NonCoreContract
from net.sf.chellow.physical import HhStartDate, MpanCore
from net.sf.chellow.monad.types import MonadDate
from java.util import Calendar
from java.lang import System

def get_triad_dates(date, data_source):
    rate_script = contract.rateScript(date)
    return data_source.rate(rate_script, 'triad_dates')


def triad(bill, dso_contract, month_begin, month_end, data_source):
    timing = System.currentTimeMillis()
    #data_source.pw.println("starting triad " + str(System.currentTimeMillis() - timing) + "month begin " + str(month_begin) + " month end " + str(month_end))

    utc_cal = MonadDate.getCalendar()
    utc_cal.setTime(month_begin.getDate())
    month_num = utc_cal.get(Calendar.MONTH)

    # Get start of last financial year
    while utc_cal.get(Calendar.MONTH) != Calendar.APRIL:
        utc_cal.add(Calendar.MONTH, -1)
    financial_year_start = HhStartDate(utc_cal.getTime())
    utc_cal.add(Calendar.YEAR, -1)
    last_financial_year_start = HhStartDate(utc_cal.getTime())

    triad_dates = []
    for dt in get_triad_dates(last_financial_year_start, data_source):
        utc_cal.setTime(dt.getDate())
        utc_cal.add(Calendar.YEAR, 1)
        triad_dates.append(HhStartDate(utc_cal.getTime()))
    #data_source.pw.println("triad dates " + str(triad_dates))
    est_triad_kws = [data_source.create_whole_data(t_date, t_date, financial_year_start)['data'][0] for t_date in triad_dates]

    #pw.println("finished getting data " + str(System.currentTimeMillis() - timing))
    if data_source.site_id is None and (data_source.is_new or triad_dates[2].before(MpanCore.getMpanCore(data_source.id).getSupply().getGenerationFirst().getStartDate())):
        triad_rate_script = NonCoreContract.getNonCoreContract("TRIAD Estimates").rateScript(month_begin)
        triad_estimates = data_source.rate(triad_rate_script, 'triad_estimates')
        if data_source.id not in triad_estimates:
             raise Exception('The id ' + data_source.id + ' cannot be found in the list of triad estimates in the rate script.')
        est_triad_kw = triad_estimates[data_source.id]
        est_triad_kws = [{'gsp-kw': est_triad_kw, 'msp-kw': est_triad_kw, 'laf': 1, 'end-date': tdate.getDate()} for tdate in triad_dates]
    
    triad_calc(bill, 'triad-estimate', dso_contract, est_triad_kws, financial_year_start, data_source)

    est_triad_gbp = bill['triad-estimate-rate'] * bill['triad-estimate-gsp-kw'] / 12

    if month_num == Calendar.MARCH and not data_source.is_new:
        #T1 Date, T1 MSP kW, T1 Status, T1 LAF, T1 GSP kW, T2 Date, T2 MSP kW, T2 Status, T2 LAF, T2 GSP kW, T3 Date, T3 MSP kW, T3 Status, T3 LAF, T3 GSP kW, GSP kW, GBP
        #data_source.pw.println('t dates ' + str(get_triad_dates(month_begin, data_source)))
        triad_kws = [data_source.create_whole_data(t_date, t_date, data_source.forecast_date)['data'][0] for t_date in get_triad_dates(month_begin, data_source)]

        triad = triad_calc(bill, 'triad-actual', dso_contract, triad_kws, financial_year_start, data_source)
        bill['triad-actual-gbp'] = bill['triad-actual-rate'] * bill['triad-actual-gsp-kw']

        utc_cal.setTime(month_end.getDate())
        sup = MpanCore.getMpanCore(data_source.id).getSupply()
        sup_gen = sup.getGeneration(HhStartDate(utc_cal.getTime()))
        est_months = 0
        while sup_gen is not None and utc_cal.getTime().after(financial_year_start.getDate()) :
            est_months += 1
            utc_cal.add(Calendar.MONTH, -1)
            sup_gen = sup.getGeneration(HhStartDate(utc_cal.getTime()))
        est_total = est_triad_gbp * est_months
        bill['triad-estimate-months'] = est_months
        bill['triad-estimate-gbp'] = est_triad_gbp * est_months * -1
    #data_source.pw.println("finished triad " + str(System.currentTimeMillis() - timing))
    else:
        bill['triad-estimate-gbp'] = est_triad_gbp


def triad_calc(bill, prefix, dso_contract, triad_data, financial_year_start, data_source):
    gsp_kw = 0
    for i in range(len(triad_data)):
        triad_hh = triad_data[i]
        triad_prefix = prefix + '-' + str(i)
        bill[triad_prefix + '-date'] = HhStartDate(triad_hh['hist-start-date'])
        bill[triad_prefix + '-msp-kw'] = triad_hh['msp-kw']
        bill[triad_prefix + '-status'] = triad_hh['status']
        bill[triad_prefix + '-laf'] = triad_hh['laf']
        bill[triad_prefix + '-gsp-kw'] = triad_hh['gsp-kw']
        gsp_kw += triad_hh['gsp-kw']

    bill[prefix + '-gsp-kw'] = gsp_kw / 3
    bill[prefix + '-rate'] = data_source.rate(data_source.contract_function(dso_contract, 'get_rate_script')(financial_year_start), 'triad')]]></value>
        <value><![CDATA[from net.sf.chellow.physical import HhStartDate

def triad_dates():
    return [HhStartDate("2005-11-28T17:00Z"), HhStartDate("2006-01-05T17:00Z"), HhStartDate("2006-02-03T17:30Z")]]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract-rate-script]]></value>
        <value><![CDATA[TRIAD]]></value>
        <value><![CDATA[2006-04-01T00:00Z]]></value>
        <value><![CDATA[from net.sf.chellow.physical import HhStartDate

def triad_dates():
    return [HhStartDate("2007-01-23T17:00Z"), HhStartDate("2006-12-20T17:00Z"), HhStartDate("2007-02-08T17:30Z")]]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract-rate-script]]></value>
        <value><![CDATA[TRIAD]]></value>
        <value><![CDATA[2007-04-01T00:00Z]]></value>
        <value><![CDATA[from net.sf.chellow.physical import HhStartDate

def triad_dates():
    return [HhStartDate("2007-12-17T17:00Z"), HhStartDate("2008-01-03T17:00Z"), HhStartDate("2007-11-26T17:00Z")]]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract-rate-script]]></value>
        <value><![CDATA[TRIAD]]></value>
        <value><![CDATA[2008-04-01T00:00Z]]></value>
        <value><![CDATA[from net.sf.chellow.physical import HhStartDate

def triad_dates():
    return [HhStartDate("2009-01-06T17:00Z"), HhStartDate("2008-12-01T17:00Z"), HhStartDate("2008-12-15T17:00Z")]]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract-rate-script]]></value>
        <value><![CDATA[TRIAD]]></value>
        <value><![CDATA[2009-04-01T00:00Z]]></value>
        <value><![CDATA[from net.sf.chellow.physical import HhStartDate

def triad_dates():
    return [HhStartDate("2010-01-07T17:00Z"), HhStartDate("2010-01-25T17:00Z"), HhStartDate("2009-12-15T17:00Z")]]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract-rate-script]]></value>
        <value><![CDATA[TRIAD]]></value>
        <value><![CDATA[2010-04-01T00:00Z]]></value>
        <value><![CDATA[from net.sf.chellow.physical import HhStartDate

def triad_dates():
    return [HhStartDate("2008-12-01T17:30Z"), HhStartDate("2008-12-15T17:30Z"), HhStartDate("2009-01-06T17:30Z")]]]></value>
    </line>
    <line>
        <value><![CDATA[insert]]></value>
        <value><![CDATA[non-core-contract]]></value>
        <value><![CDATA[POOL]]></value>
        <value><![CDATA[vat]]></value>
        <value><![CDATA[2010-03-25T00:00Z]]></value>
        <value><![CDATA[]]></value>
        <value><![CDATA[]]></value>
        <value><![CDATA[]]></value>
    </line>
</csv>
